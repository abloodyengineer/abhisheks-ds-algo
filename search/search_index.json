{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"1-time-and-space-complexity/time-complexity/","title":"Time Complexity","text":"<p>The time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the input. Note that the time to run is a function of the length of the input and not the actual execution time of the machine on which the algorithm is running on.</p>"},{"location":"1-time-and-space-complexity/time-complexity/#examples-iterative","title":"Examples - Iterative","text":"<p>Lets go through examples to understand the concepts.</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-1-on","title":"Example-1 | O(n)","text":"<pre><code>for i in range(n):\n    print(i)\n</code></pre> <p>loop will run for 1+1+1+1+1+...n times = n. Hence O(n)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-2-on2","title":"Example-2 | O(n^2)","text":"<p><pre><code>for i in range(n):\n    for j in range(n):\n        print(i)\n</code></pre> Outer loop will run for 1+1+1+1+1+...n times = n Inner loop will run for 1+1+1+1+1+...n times = n As these are nested, total time = n^2 Hence O(n^2)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-3-olog-n","title":"Example-3 | O(log n)","text":"<p><pre><code>index=0\nsize = 129\nwhile index &lt; size:\n    print(index)\n    index *= 2\n</code></pre> loop will run for 12222*...k times = 2^k Complexity should be k then Loop will stop when 2^k &gt;=n Hence, we can calculate k 2^k=n k=log n Hence O(log n)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#examples-recursive","title":"Examples - Recursive","text":""},{"location":"1-time-and-space-complexity/time-complexity/#example-1-fibonacci","title":"Example-1 | Fibonacci","text":"<p><pre><code>T(n)=k+T(n-1)  \nT(n-1)=k+T(n-2)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=k*n</p> <p>Hence, O(n)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-2-binary-search","title":"Example-2 | Binary search","text":"<p><pre><code>T(n)=k+T(n/2)  \nT(n/2)=k+T(n/4)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=a(number of steps)* k</p> <p>Now, a= log n(which is number of steps) Hence, T(n) = k*log n</p> <p>Hence, O(log n)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-3-merge-sort","title":"Example-3 | Merge sort","text":"<ul> <li>Break into 2 arrays, left and right</li> <li>Sort using recursion</li> <li>Merge into a new array (O(kn))</li> <li>Copy new array content to original array (O(kn))</li> </ul> <p><pre><code>T(n)=k+T(n/2)+T(n/2)+kn+kn  \nT(n)=2T(n/2)+kn  \n\n2T(n/2)=4T(n/4)+kn (multiplied both side by 2)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=a(number of steps)* nk</p> <p>Now, a= log n(which is number of steps) Hence, T(n) = nk*log n</p> <p>Hence, O(nlog n)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-4-fibonacci","title":"Example-4 | Fibonacci","text":"<p><pre><code>T(n)=T(n-1)+T(n-2)\n\nForms a binary tree with n levels\n\nTotal nodes = 1+2^1+2^2+2^3+...2^n  \nEach node = k operation  \n\nT.C = k*Total nodes  \n    = k*((2^n+1)-1) [Formula]  \n    =k*2^n [approx]  \n</code></pre> Hence, O(2^n)</p>"},{"location":"2-sorting/1-selection-sort/","title":"Selection Sort","text":""},{"location":"2-sorting/1-selection-sort/#intuition","title":"Intuition","text":"<ul> <li>Move minimum to front</li> <li>Loop through the list n times</li> <li>In each loop, take the i-th element as temp mini</li> <li>find the minimum in the array from i to n</li> <li>swap mini with i-th element</li> <li>continue by increasing i in each step</li> </ul>"},{"location":"2-sorting/1-selection-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    # Selection sort- move min to front - O(n^2) - TLE\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        for i in range(n-1):\n            mini=i\n            for j in range(i,n):\n                if nums[j]&lt;nums[mini]:\n                    mini=j\n            self.swap(i,mini, nums)\n        return nums\n\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-sorting/1-selection-sort/#time-complexity","title":"Time complexity","text":"<p>O(N^2)</p>"},{"location":"2-sorting/1-selection-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-sorting/1-selection-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-sorting/2-bubble-sort/","title":"Bubble Sort","text":""},{"location":"2-sorting/2-bubble-sort/#intuition","title":"Intuition","text":"<ul> <li>Move maximun to end by adjacent swaps</li> <li>Loop i from end of list to beginning</li> <li>Loop j from 0 to i(dont include i)</li> <li>swap j with j+1 if j&gt;j+1, that is, moving the max to end</li> <li>after i goes from n-1 to 0, the array will be sorted</li> </ul>"},{"location":"2-sorting/2-bubble-sort/#code","title":"Code","text":"<pre><code># Bubble sort- move max to end - O(n^2) - TLE\ndef sortArray(self, nums: List[int]) -&gt; List[int]:\n    n=len(nums)\n    for i in range(n-1,-1,-1):\n        for j in range(0, i):\n            if nums[j]&gt;nums[j+1]:\n                self.swap(j,j+1,nums)\n    return nums\ndef swap(self, first, second, nums):\n    temp=nums[first]\n    nums[first]=nums[second]\n    nums[second]=temp\n</code></pre> <pre><code>class Solution:\n    # Bubble sort- move max to end - little optimized - O(n^2), best case O(n) if array already sorted - TLE\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        for i in range(n-1,-1,-1):\n            swapped=0\n            for j in range(0, i):\n                if nums[j]&gt;nums[j+1]:\n                    self.swap(j,j+1,nums)\n                    swapped=1\n            if swapped==0:\n                return nums\n        return nums\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-sorting/2-bubble-sort/#time-complexity","title":"Time complexity","text":"<p>O(N^2)</p>"},{"location":"2-sorting/2-bubble-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-sorting/2-bubble-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-sorting/3-insertion-sort/","title":"Insertion Sort","text":""},{"location":"2-sorting/3-insertion-sort/#intuition-opposite-of-bubble-sort","title":"Intuition - Opposite of Bubble sort","text":"<ul> <li>Move minimum to front by adjacent swaps</li> <li>Loop i from beginning to end of list</li> <li>Loop j from i to 0</li> <li>swap j with j-1 if j, that is, moving the min to beginning <li>after i goes from 0 to n, the array will be sorted</li>"},{"location":"2-sorting/3-insertion-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    # Insertion sort- bring lower value to beginning - compare each element with its left element, swap if element is smaller - O(n^2) - TLE\n    # Best case O(n)\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        for i in range(n):\n            for j in range(i,0,-1):\n                if nums[j]&lt;nums[j-1]:\n                    self.swap(j-1,j,nums)\n        return nums\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-sorting/3-insertion-sort/#time-complexity","title":"Time complexity","text":"<p>O(N^2)</p>"},{"location":"2-sorting/3-insertion-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-sorting/3-insertion-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-sorting/4-merge-sort/","title":"Merge Sort","text":""},{"location":"2-sorting/4-merge-sort/#intuition","title":"Intuition","text":"<ul> <li>Calculate mid = (high+low)/2</li> <li>Call merge sort recursively from low to mid</li> <li>Call merge sort recursively from mid+1 to high</li> <li>Finally merge the two halves from low to high using mid</li> </ul>"},{"location":"2-sorting/4-merge-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    # Merge-sort - O(nlogn)\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        self.mergeSort(nums,0, n-1)\n        return nums\n\n    def mergeSort(self, nums, low, high):\n        if low&gt;=high:\n            return\n        mid=(high+low)//2\n        self.mergeSort(nums, low, mid)\n        self.mergeSort(nums, mid+1, high)\n        self.merge(nums, low,mid,high)\n\n    def merge(self, nums, low,mid,high):\n        temp=[]\n        left=low\n        right=mid+1\n        while left&lt;=mid and right&lt;=high:\n            if nums[left]&lt;nums[right]:\n                temp.append(nums[left])\n                left+=1\n            else:\n                temp.append(nums[right])\n                right+=1\n        while left&lt;=mid:\n            temp.append(nums[left])\n            left+=1\n        while right&lt;=high:\n            temp.append(nums[right])\n            right+=1\n        for i in range(low,high+1):\n            nums[i]=temp[i-low]\n</code></pre>"},{"location":"2-sorting/4-merge-sort/#time-complexity","title":"Time complexity","text":"<p>O(nlogn)</p>"},{"location":"2-sorting/4-merge-sort/#space-complexity","title":"Space Complexity","text":"<p>O(n) + recursion stack Additional space is required for the temporary array used during merging.</p>"},{"location":"2-sorting/4-merge-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-sorting/5-quick-sort/","title":"Quick Sort","text":"<p>Not suitable if array is sorted</p>"},{"location":"2-sorting/5-quick-sort/#intuition","title":"Intuition","text":"<ul> <li>Call pivot which appoints a pivot, moves everything smaller than pivot to left and larger to right of pivot. move the pivot to the correct place. Return the pivot index</li> <li>Call quick sort recursively again from low to pivot_index-1</li> <li>Call quick sort recursively again from pivot_index+1 to high</li> <li>Pivot function:<ul> <li>take the low index as pivot</li> <li>i=low, j=high</li> <li>while i &lt;= high, and nums[i] &lt;= pivot, increment i</li> <li>while j&gt;=low , and nums[j] &gt; pivot, decrement j</li> <li>What this means is we stop i when i is at an index whose value is higher than pivot and j at an index whose value is smaller than equal to pivot.</li> <li>if i and j did not cross, we can swap i and j so that smaller is at left, larger is at right</li> <li>if i and j cross each other, means we have done all movement, now we can place the pivot in its correct index.</li> <li>correct index of pivot will be j as it stands at one place left of the index which is just higher than pivot</li> <li>so, swap low(pivot index) with j</li> <li>also return j as the pivot index, so that next recursion calls can be from 0 to j-1 and j+1 to end, that is excluding j</li> </ul> </li> </ul>"},{"location":"2-sorting/5-quick-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    def sortColors(self, nums: List[int]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        self.quick_sort(nums,0,n-1)\n\n    def quick_sort(self, nums, low,high):\n        if low&lt;high:\n\n            pivot_index=self.pivot(nums,low,high)\n            self.quick_sort(nums,low,pivot_index-1)\n            self.quick_sort(nums,pivot_index+1, high)\n\n    def pivot(self, nums, low, high):\n        pivot =nums[low]\n        i=low\n        j=high\n        while i&lt;j:\n            while i&lt;=high and nums[i]&lt;=pivot: #less than equal to to consider the equal to scenario\n                i+=1\n            while j&gt;=low and nums[j]&gt;pivot: #just greater than as equal to scenario checked above already\n                j-=1\n            if i&lt;j:\n                self.swap(i,j,nums)\n        self.swap(low,j, nums)\n        return j\n\n\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-sorting/5-quick-sort/#time-complexity","title":"Time complexity","text":"<p>O(nlogn)</p>"},{"location":"2-sorting/5-quick-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-sorting/5-quick-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"}]}