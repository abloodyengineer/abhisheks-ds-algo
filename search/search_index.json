{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"1-time-and-space-complexity/time-complexity/","title":"Time Complexity","text":"<p>The time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the input. Note that the time to run is a function of the length of the input and not the actual execution time of the machine on which the algorithm is running on.</p>"},{"location":"1-time-and-space-complexity/time-complexity/#examples-iterative","title":"Examples - Iterative","text":"<p>Lets go through examples to understand the concepts.</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-1-on","title":"Example-1 | O(n)","text":"<pre><code>for i in range(n):\n    print(i)\n</code></pre> <p>loop will run for 1+1+1+1+1+...n times = n. Hence O(n)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-2-on2","title":"Example-2 | O(n^2)","text":"<p><pre><code>for i in range(n):\n    for j in range(n):\n        print(i)\n</code></pre> Outer loop will run for 1+1+1+1+1+...n times = n Inner loop will run for 1+1+1+1+1+...n times = n As these are nested, total time = n^2 Hence O(n^2)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-3-olog-n","title":"Example-3 | O(log n)","text":"<p><pre><code>index=0\nsize = 129\nwhile index &lt; size:\n    print(index)\n    index *= 2\n</code></pre> loop will run for 12222*...k times = 2^k Complexity should be k then Loop will stop when 2^k &gt;=n Hence, we can calculate k 2^k=n k=log n Hence O(log n)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#examples-recursive","title":"Examples - Recursive","text":""},{"location":"1-time-and-space-complexity/time-complexity/#example-1-fibonacci","title":"Example-1 | Fibonacci","text":"<p><pre><code>T(n)=k+T(n-1)  \nT(n-1)=k+T(n-2)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=k*n</p> <p>Hence, O(n)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-2-binary-search","title":"Example-2 | Binary search","text":"<p><pre><code>T(n)=k+T(n/2)  \nT(n/2)=k+T(n/4)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=a(number of steps)* k</p> <p>Now, a= log n(which is number of steps) Hence, T(n) = k*log n</p> <p>Hence, O(log n)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-3-merge-sort","title":"Example-3 | Merge sort","text":"<ul> <li>Break into 2 arrays, left and right</li> <li>Sort using recursion</li> <li>Merge into a new array (O(kn))</li> <li>Copy new array content to original array (O(kn))</li> </ul> <p><pre><code>T(n)=k+T(n/2)+T(n/2)+kn+kn  \nT(n)=2T(n/2)+kn  \n\n2T(n/2)=4T(n/4)+kn (multiplied both side by 2)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=a(number of steps)* nk</p> <p>Now, a= log n(which is number of steps) Hence, T(n) = nk*log n</p> <p>Hence, O(nlog n)</p>"},{"location":"1-time-and-space-complexity/time-complexity/#example-4-fibonacci","title":"Example-4 | Fibonacci","text":"<p><pre><code>T(n)=T(n-1)+T(n-2)\n\nForms a binary tree with n levels\n\nTotal nodes = 1+2^1+2^2+2^3+...2^n  \nEach node = k operation  \n\nT.C = k*Total nodes  \n    = k*((2^n+1)-1) [Formula]  \n    =k*2^n [approx]  \n</code></pre> Hence, O(2^n)</p>"},{"location":"2-sorting/1-selection-sort/","title":"Selection Sort","text":""},{"location":"2-sorting/1-selection-sort/#intuition","title":"Intuition","text":"<ul> <li>Move minimum to front</li> <li>Loop through the list n times</li> <li>In each loop, take the i-th element as temp mini</li> <li>find the minimum in the array from i to n</li> <li>swap mini with i-th element</li> <li>continue by increasing i in each step</li> </ul>"},{"location":"2-sorting/1-selection-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    # Selection sort- move min to front - O(n^2) - TLE\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        for i in range(n-1):\n            mini=i\n            for j in range(i,n):\n                if nums[j]&lt;nums[mini]:\n                    mini=j\n            self.swap(i,mini, nums)\n        return nums\n\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-sorting/1-selection-sort/#time-complexity","title":"Time complexity","text":"<p>O(N^2)</p>"},{"location":"2-sorting/1-selection-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-sorting/1-selection-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-sorting/2-bubble-sort/","title":"Bubble Sort","text":""},{"location":"2-sorting/2-bubble-sort/#intuition","title":"Intuition","text":"<ul> <li>Move maximun to end by adjacent swaps</li> <li>Loop i from end of list to beginning</li> <li>Loop j from 0 to i(dont include i)</li> <li>swap j with j+1 if j&gt;j+1, that is, moving the max to end</li> <li>after i goes from n-1 to 0, the array will be sorted</li> </ul>"},{"location":"2-sorting/2-bubble-sort/#code","title":"Code","text":"<pre><code># Bubble sort- move max to end - O(n^2) - TLE\ndef sortArray(self, nums: List[int]) -&gt; List[int]:\n    n=len(nums)\n    for i in range(n-1,-1,-1):\n        for j in range(0, i):\n            if nums[j]&gt;nums[j+1]:\n                self.swap(j,j+1,nums)\n    return nums\ndef swap(self, first, second, nums):\n    temp=nums[first]\n    nums[first]=nums[second]\n    nums[second]=temp\n</code></pre> <pre><code>class Solution:\n    # Bubble sort- move max to end - little optimized - O(n^2), best case O(n) if array already sorted - TLE\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        for i in range(n-1,-1,-1):\n            swapped=0\n            for j in range(0, i):\n                if nums[j]&gt;nums[j+1]:\n                    self.swap(j,j+1,nums)\n                    swapped=1\n            if swapped==0:\n                return nums\n        return nums\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-sorting/2-bubble-sort/#time-complexity","title":"Time complexity","text":"<p>O(N^2)</p>"},{"location":"2-sorting/2-bubble-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-sorting/2-bubble-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-sorting/3-insertion-sort/","title":"Insertion Sort","text":""},{"location":"2-sorting/3-insertion-sort/#intuition-opposite-of-bubble-sort","title":"Intuition - Opposite of Bubble sort","text":"<ul> <li>Move minimum to front by adjacent swaps</li> <li>Loop i from beginning to end of list</li> <li>Loop j from i to 0</li> <li>swap j with j-1 if j, that is, moving the min to beginning <li>after i goes from 0 to n, the array will be sorted</li>"},{"location":"2-sorting/3-insertion-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    # Insertion sort- bring lower value to beginning - compare each element with its left element, swap if element is smaller - O(n^2) - TLE\n    # Best case O(n)\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        for i in range(n):\n            for j in range(i,0,-1):\n                if nums[j]&lt;nums[j-1]:\n                    self.swap(j-1,j,nums)\n        return nums\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-sorting/3-insertion-sort/#time-complexity","title":"Time complexity","text":"<p>O(N^2)</p>"},{"location":"2-sorting/3-insertion-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-sorting/3-insertion-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-sorting/4-merge-sort/","title":"Merge Sort","text":""},{"location":"2-sorting/4-merge-sort/#intuition","title":"Intuition","text":"<ul> <li>Calculate mid = (high+low)/2</li> <li>Call merge sort recursively from low to mid</li> <li>Call merge sort recursively from mid+1 to high</li> <li>Finally merge the two halves from low to high using mid</li> </ul>"},{"location":"2-sorting/4-merge-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    # Merge-sort - O(nlogn)\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        self.mergeSort(nums,0, n-1)\n        return nums\n\n    def mergeSort(self, nums, low, high):\n        if low&gt;=high:\n            return\n        mid=(high+low)//2\n        self.mergeSort(nums, low, mid)\n        self.mergeSort(nums, mid+1, high)\n        self.merge(nums, low,mid,high)\n\n    def merge(self, nums, low,mid,high):\n        temp=[]\n        left=low\n        right=mid+1\n        while left&lt;=mid and right&lt;=high:\n            if nums[left]&lt;nums[right]:\n                temp.append(nums[left])\n                left+=1\n            else:\n                temp.append(nums[right])\n                right+=1\n        while left&lt;=mid:\n            temp.append(nums[left])\n            left+=1\n        while right&lt;=high:\n            temp.append(nums[right])\n            right+=1\n        for i in range(low,high+1):\n            nums[i]=temp[i-low]\n</code></pre>"},{"location":"2-sorting/4-merge-sort/#time-complexity","title":"Time complexity","text":"<p>O(nlogn)</p>"},{"location":"2-sorting/4-merge-sort/#space-complexity","title":"Space Complexity","text":"<p>O(n) + recursion stack Additional space is required for the temporary array used during merging.</p>"},{"location":"2-sorting/4-merge-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-sorting/5-quick-sort/","title":"Quick Sort","text":"<p>Not suitable if array is sorted</p>"},{"location":"2-sorting/5-quick-sort/#intuition","title":"Intuition","text":"<ul> <li>Call pivot which appoints a pivot, moves everything smaller than pivot to left and larger to right of pivot. move the pivot to the correct place. Return the pivot index</li> <li>Call quick sort recursively again from low to pivot_index-1</li> <li>Call quick sort recursively again from pivot_index+1 to high</li> <li>Pivot function:<ul> <li>take the low index as pivot</li> <li>i=low, j=high</li> <li>while i &lt;= high, and nums[i] &lt;= pivot, increment i</li> <li>while j&gt;=low , and nums[j] &gt; pivot, decrement j</li> <li>What this means is we stop i when i is at an index whose value is higher than pivot and j at an index whose value is smaller than equal to pivot.</li> <li>if i and j did not cross, we can swap i and j so that smaller is at left, larger is at right</li> <li>if i and j cross each other, means we have done all movement, now we can place the pivot in its correct index.</li> <li>correct index of pivot will be j as it stands at one place left of the index which is just higher than pivot</li> <li>so, swap low(pivot index) with j</li> <li>also return j as the pivot index, so that next recursion calls can be from 0 to j-1 and j+1 to end, that is excluding j</li> </ul> </li> </ul>"},{"location":"2-sorting/5-quick-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    def sortColors(self, nums: List[int]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        self.quick_sort(nums,0,n-1)\n\n    def quick_sort(self, nums, low,high):\n        if low&lt;high:\n\n            pivot_index=self.pivot(nums,low,high)\n            self.quick_sort(nums,low,pivot_index-1)\n            self.quick_sort(nums,pivot_index+1, high)\n\n    def pivot(self, nums, low, high):\n        pivot =nums[low]\n        i=low\n        j=high\n        while i&lt;j:\n            while i&lt;=high and nums[i]&lt;=pivot: #less than equal to to consider the equal to scenario\n                i+=1\n            while j&gt;=low and nums[j]&gt;pivot: #just greater than as equal to scenario checked above already\n                j-=1\n            if i&lt;j:\n                self.swap(i,j,nums)\n        self.swap(low,j, nums)\n        return j\n\n\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-sorting/5-quick-sort/#time-complexity","title":"Time complexity","text":"<p>O(nlogn)</p>"},{"location":"2-sorting/5-quick-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-sorting/5-quick-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"3-array/1-second-largest-element-in-array/","title":"Second largest element in array","text":"<p>Problem link - GFG</p>"},{"location":"3-array/1-second-largest-element-in-array/#intuition","title":"Intuition","text":"<ul> <li>initialize largest1 and largest2</li> <li>Loop through array</li> <li>if you get an element greater than largest1, make largest2 = largest 1 now, and largest1 = arr[i]</li> <li>else, if element is greater than largest2, make largest2=arr[i]</li> </ul> <pre><code>class Solution:\n    def print2largest(self,arr, n):\n        # code here\n        largest1=arr[0]\n        largest2=-1\n        for i in range(1,n):\n            if arr[i]&gt;largest1:\n                largest2=largest1\n                largest1=arr[i]\n            elif arr[i]&lt;largest1 and arr[i]&gt;largest2:\n                largest2=arr[i]\n        return largest2\n</code></pre>"},{"location":"3-array/2-remove-duplicates-from-sorted-array/","title":"Remove duplicates from sorted array","text":"<p>Problem link - Leetcode</p>"},{"location":"3-array/2-remove-duplicates-from-sorted-array/#intuition-brute-force-using-set","title":"Intuition - Brute force - using set","text":"<p>Time complexity - O(nlogn)</p> <p>Space complexity - O(n) for set</p> <ul> <li>store nums in a set and sort it. make sure tor assign this to nums</li> <li>return the length of nums, which is now a set</li> </ul> <pre><code>class Solution:\n    def removeDuplicates(self, nums: List[int]) -&gt; int:\n        nums[:]=sorted(set(nums))\n        return len(nums)\n</code></pre>"},{"location":"3-array/2-remove-duplicates-from-sorted-array/#intuition-optimal-force-using-two-pointers","title":"Intuition - Optimal force - using two pointers","text":"<p>Time complexity - O(n)</p> <p>Space complexity - O(1)</p> <ul> <li>take left = 0, right = 0</li> <li>loop right from 0 to n</li> <li>if nums[right] is not equal to nums[left], assign nums[right] nums[left+1] and increment left by 1. This means, when we fin a new element, we place it next to first occurence of old element</li> <li>length of unique elements will be left+1</li> </ul> <pre><code>class Solution:\n    # Optimal approach - 2 pointers - time - O(n) - space - O(1)\n    def removeDuplicates(self, nums: List[int]) -&gt; int:\n        n=len(nums)\n        left=0\n        right=0\n        while right &lt; n:\n            if nums[right] != nums[left]:\n                nums[left+1]=nums[right]\n                left+=1\n            right+=1\n        return left+1\n</code></pre>"},{"location":"3-array/3-left-rotate-an-array-by-1-place/","title":"Left rotate an array by 1 place","text":"<p>Problem link - Leetcode</p>"},{"location":"3-array/3-left-rotate-an-array-by-1-place/#intuition","title":"Intuition","text":"<p>Time complexity - O(n)</p> <p>Space complexity - O(1)</p> <ul> <li>store first element in a temp variable</li> <li>loop through array from 1 to n</li> <li>place 1st index in 0th, 2nd in 1st...so on</li> <li>place temp in last index</li> </ul> <pre><code>Easy\n</code></pre>"},{"location":"3-array/4-right-rotate-an-array-by-k-place/","title":"Left rotate an array by k places","text":"<p>Problem link - Leetcode</p>"},{"location":"3-array/4-right-rotate-an-array-by-k-place/#intuition-1-using-temp-array","title":"Intuition 1 - using temp array","text":"<p>Time complexity - O(n+d)</p> <p>Space complexity - O(N)</p> <ul> <li>store last k elements in a temp array</li> <li>loop through array from end to k</li> <li>move elements from 0 to n-k to end</li> <li>fill up starting k places with elements from temp</li> </ul> <pre><code>class Solution:\n    # Time -O(n+d) Extra Space - O(N)\n    def rotate(self, nums: List[int], k: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        new_k=k%n\n        temp=nums[n-new_k:n]\n        for i in range(n-1,new_k-1,-1):\n            nums[i]=nums[i-new_k]\n        for i in range(len(temp)):\n            nums[i]=temp[i]\n</code></pre>"},{"location":"3-array/4-right-rotate-an-array-by-k-place/#intuition-2-using-reversing-technique","title":"Intuition 2 - using reversing technique","text":"<p>Time complexity - O(n)</p> <p>Space complexity - O(1)</p> <ul> <li>Reverse 0 to n-k</li> <li>Reverse n-k to end</li> <li>Reverse 0 to end</li> </ul> <pre><code>class Solution:\n    # time - O(N) extra space - O(1) \n    def rotate(self, nums: List[int], k: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        new_k=k%n\n        self.reverse(0, n-new_k, nums)\n        self.reverse(n-new_k, n, nums)\n        self.reverse(0,n,nums)\n    def reverse(self, left, right,nums):\n        while left&lt;right-1:\n            temp=nums[left]\n            nums[left]=nums[right-1]\n            nums[right-1]=temp\n            left+=1\n            right-=1\n</code></pre>"},{"location":"3-array/5-move-zeroes-to-end/","title":"Move zeroes to end","text":"<p>Problem link - Leetcode</p>"},{"location":"3-array/5-move-zeroes-to-end/#intuition-1-optimal","title":"Intuition 1 - optimal","text":"<p>Time complexity - O(n)</p> <p>Space complexity - O(1)</p> <ul> <li>initialize a variable zero_index with 0</li> <li>loop through array from 0 to end</li> <li>if element is non zero, swap it with the last zero_index</li> <li>increment zero_index as zero moved to the right by one place due to swap</li> <li>slowly all non zeros will move to left and all zeros to end</li> </ul> <pre><code>class Solution:\n    def moveZeroes(self, nums: List[int]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        zero_index=0\n        for i in range(n):\n            if nums[i]!=0:\n                self.swap(i,zero_index, nums)\n                zero_index+=1\n\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"3-array/6-find-missing-number/","title":"Move zeroes to end","text":"<p>Problem link - Leetcode</p>"},{"location":"3-array/6-find-missing-number/#intuition-1-good-solution","title":"Intuition 1 - Good solution","text":"<p>Time complexity - O(2n)</p> <p>Space complexity - O(n)</p> <ul> <li>initialize a temp array with all 0s</li> <li>loop through the nums array, and mark the indexes corresponding to the elements with 1, i.e, if 2 is present in nums, mark arr[2]=1 and so on</li> <li>loop through temp array. whichever index is marked 0 is the missing number</li> </ul> <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        n=len(nums)\n        arr=[0]*(n+1)\n        for i in range(n):\n            arr[nums[i]]=1\n        for i in range(n+1):\n            if arr[i]==0:\n                return i\n</code></pre>"},{"location":"3-array/6-find-missing-number/#intuition-2-optimal-solution-1-sum","title":"Intuition 2 - Optimal solution 1 - sum","text":"<p>Time complexity - O(n)</p> <p>Space complexity - O(1)</p> <ul> <li>Find sum on first n natural numbers</li> <li>find sum of given nums array</li> <li>the difference is the missing number</li> </ul> <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        n=len(nums)\n        nsum=sum(range(n+1))\n        actual_sum=sum(nums)\n        return nsum-actual_sum\n</code></pre>"},{"location":"3-array/6-find-missing-number/#intuition-3-optimal-solution-2-xor","title":"Intuition 3 - Optimal solution 2 - xor","text":"<p>This can be solved using xor as well. Hint - Xor with first n natural numbers. the answer is the missing number because a^a=0</p> <p>so every number cancels out except the missing number</p>"},{"location":"3-array/longest-sub-array-with-sum-k/","title":"Longest Sub-Array with Sum K","text":"<p>Problem link - GFG</p>"},{"location":"3-array/longest-sub-array-with-sum-k/#only-positives","title":"Only positives","text":""},{"location":"3-array/longest-sub-array-with-sum-k/#intuition-better-approach-using-hashmap","title":"Intuition - Better approach using hashmap","text":"<p>Time complexity - O(nlogn) n for loop, logn to find in hashmap</p> <p>Space complexity - O(n) for hashmap</p> <ul> <li>create a hashmap, we will store cumulative sum until i as key, and i as value, in hashmap</li> <li>Loop through array using i</li> <li>keep a cumulative sum of elements up to i</li> <li>if sum == k, then max_len should be equal to max of previous max_len and current length, i.e, i+1</li> <li>But if it is not equal to k, check if sum-k exists in the hashmap. This means, check if there exists a sum already in the array which, if removed, will make another subarray sum to be equal to k</li> <li>if it exists, then max_len should be equal to max of previous max_len and length of subarray from index computed in previous step to i. index of previous step in already stored in hashmap</li> <li>At the end, store the current cumulative sum in hashmap with current i as value to be retrieved later to perform above steps</li> </ul> <pre><code>class Solution:\n    def lenOfLongSubarr (self, arr, n, k) : \n        #Complete the function\n        mp={}\n        max_len=0\n        sums=0\n        for i in range(n):\n            sums+=arr[i]\n            if sums==k:\n                max_len=max(max_len,i+1)\n            elif sums-k in mp:\n                max_len=max(max_len, i-mp[sums-k])\n            if sums not in mp:\n                mp[sums]=i\n        return max_len\n</code></pre>"},{"location":"3-array/longest-sub-array-with-sum-k/#intuition-optimal-approach-using-two-pointers-prefix-sum","title":"Intuition - Optimal approach using two pointers, prefix sum","text":"<p>Could not test this as no problem with only positives</p> <p>Time complexity - O(2n) inner while will run max for n times in whole program run</p> <p>Space complexity - O(1)</p> <ul> <li>Loop through array using i</li> <li>keep a cumulative sum of elements up to i</li> <li>if sum == k, then max_len should be equal to max of previous max_len and current length, i.e, i+1</li> <li>Otherwise, we need to move to next i. But before that, check if sums is greater than k. If yes, keep removing element from j from sum until it is smaller than k.</li> <li>At the end, return max_len</li> </ul> <pre><code>class Solution:\n    def lenOfLongSubarr (self, arr, n, k):\n        max_len=0\n        sums=0\n        j=0\n        for i in range(n):\n            sums+=arr[i]\n            if sums==k:\n                max_len=max(max_len,i-j+1)\n            while j&lt;i and  sums&gt;k:\n                sums-=arr[j]\n                j+=1\n        return max_len\n</code></pre>"},{"location":"3-array/longest-sub-array-with-sum-k/#with-positives-negatives-and-zeros","title":"With positives, negatives and zeros","text":""},{"location":"3-array/longest-sub-array-with-sum-k/#intuition-optimal","title":"Intuition - Optimal","text":"<p>Time complexity - O(nlogn) n for loop, logn to find in hashmap</p> <p>Space complexity - O(n) for hashmap</p> <ul> <li>create a hashmap, we will store cumulative sum until i as key, and i as value, in hashmap</li> <li>Loop through array using i</li> <li>keep a cumulative sum of elements up to i</li> <li>if sum == k, then max_len should be equal to max of previous max_len and current length, i.e, i+1</li> <li>But if it is not equal to k, check if sum-k exists in the hashmap. This means, check if there exists a sum already in the array which, if removed, will make another subarray sum to be equal to k</li> <li>if it exists, then max_len should be equal to max of previous max_len and length of subarray from index computed in previous step to i. index of previous step in already stored in hashmap</li> <li>At the end, store the current cumulative sum in hashmap with current i as value to be retrieved later to perform above steps</li> </ul> <pre><code>class Solution:\n    def lenOfLongSubarr (self, arr, n, k) : \n        #Complete the function\n        mp={}\n        max_len=0\n        sums=0\n        for i in range(n):\n            sums+=arr[i]\n            if sums==k:\n                max_len=max(max_len,i+1)\n            elif sums-k in mp:\n                max_len=max(max_len, i-mp[sums-k])\n            if sums not in mp:\n                mp[sums]=i\n        return max_len\n</code></pre>"},{"location":"4-binary-search/1-binary-search/","title":"Binary Search","text":""},{"location":"4-binary-search/1-binary-search/#iterative","title":"Iterative","text":"<pre><code>class Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        n=len(nums)\n        low=0\n        high=n-1\n        while low&lt;=high:\n            mid=(low+high)//2\n            if nums[mid]==target:\n                return mid\n            elif nums[mid]&lt;target:\n                low=mid+1\n            else:\n                high=mid-1\n        return -1\n</code></pre>"},{"location":"5-recursion/1-subsets-1/","title":"Subsets - 1 - Elements are unique and ans cannot contain duplicates","text":""},{"location":"5-recursion/1-subsets-1/#intuition","title":"Intuition","text":"<ul> <li>Start off with empty array</li> <li>Recursively solve by either selecting a number or not</li> <li>Base condition - ind&gt;n</li> </ul>"},{"location":"5-recursion/1-subsets-1/#example","title":"Example","text":"<p>Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p> <pre><code>class Solution:\n    def subsets(self, nums: List[int]) -&gt; List[List[int]]:\n        arr=[]\n        ans=[]\n        ind=0\n        n=len(nums)\n        self.solve(nums, arr, ind,n,ans)\n        return ans\n\n    def solve(self, nums ,arr, ind, n, ans):\n        if ind&gt;=n:\n            ans.append(arr.copy())\n            return\n        arr.append(nums[ind])\n        self.solve(nums, arr, ind+1, n, ans)\n        arr.pop()\n        self.solve(nums, arr, ind+1, n, ans)\n</code></pre>"},{"location":"5-recursion/2-subsets-2/","title":"Subsets - 2 - Array nums that may contain duplicates, ans cannot have duplicates","text":""},{"location":"5-recursion/2-subsets-2/#intuition","title":"Intuition","text":"<ul> <li>As there might be duplicates, sort the array to group duplicates</li> <li>we will start off with an empty array and put that in ans array</li> <li>we will loop through each element, and put it in ans array if not duplicate</li> <li>if duplicate, continue</li> </ul>"},{"location":"5-recursion/2-subsets-2/#example","title":"Example","text":"<p>Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]</p> <pre><code>class Solution:\n    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: \n        nums.sort()\n        n=len(nums)\n        ans=[]\n        ind=0\n        self.solve(nums, [], ind, n, ans )\n        return ans\n\n    def solve(self, nums, arr, ind, n, ans):\n        print(ind,arr)\n        ans.append(arr.copy())\n        for i in range(ind,n):\n            if i!=ind and nums[i]==nums[i-1]:\n                continue\n            arr.append(nums[i])\n            # here it is i+1 and not ind+1 as we are moving to the next i. This is ind in permutation 1\n            self.solve(nums, arr, i+1, n, ans)\n            arr.pop()\n</code></pre>"},{"location":"5-recursion/3-permutations/","title":"Permutations","text":""},{"location":"5-recursion/3-permutations/#intuition","title":"Intuition","text":"<ul> <li>loop through each element in array</li> <li>swap that element in ind with everything from ind to n using i variable</li> </ul>"},{"location":"5-recursion/3-permutations/#example","title":"Example","text":"<p>Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p> <pre><code>class Solution:\n    def permute(self, nums: List[int]) -&gt; List[List[int]]:\n        n=len(nums)\n        ans=[]\n        ind=0\n        self.solve(nums, ind, n, ans)\n        return ans\n\n    def solve(self, nums,ind,n,ans):\n        if ind==n:\n            ans.append(nums.copy())\n            return\n\n        for i in range(ind,n):\n            # swapping from current index ind to n\n            self.swap(nums,ind,i)\n            # ind+1 because we are moving to the next index to start swapping from ind to n\n            self.solve(nums, ind+1, n, ans)\n            # backtrack\n            self.swap(nums,ind,i)\n    def swap(self, nums, ind,i):\n        temp=nums[ind]\n        nums[ind]=nums[i]\n        nums[i]=temp\n</code></pre>"}]}