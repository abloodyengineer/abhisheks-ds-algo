{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"time-and-space-complexity/time-complexity/","title":"Time Complexity","text":"<p>The time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the input. Note that the time to run is a function of the length of the input and not the actual execution time of the machine on which the algorithm is running on.</p>"},{"location":"time-and-space-complexity/time-complexity/#examples-iterative","title":"Examples - Iterative","text":"<p>Lets go through examples to understand the concepts.</p>"},{"location":"time-and-space-complexity/time-complexity/#example-1-on","title":"Example-1 | O(n)","text":"<pre><code>for i in range(n):\n    print(i)\n</code></pre> <p>loop will run for 1+1+1+1+1+...n times = n. Hence O(n)</p>"},{"location":"time-and-space-complexity/time-complexity/#example-2-on2","title":"Example-2 | O(n^2)","text":"<p><pre><code>for i in range(n):\n    for j in range(n):\n        print(i)\n</code></pre> Outer loop will run for 1+1+1+1+1+...n times = n Inner loop will run for 1+1+1+1+1+...n times = n As these are nested, total time = n^2 Hence O(n^2)</p>"},{"location":"time-and-space-complexity/time-complexity/#example-3-olog-n","title":"Example-3 | O(log n)","text":"<p><pre><code>index=0\nsize = 129\nwhile index &lt; size:\n    print(index)\n    index *= 2\n</code></pre> loop will run for 12222*...k times = 2^k Complexity should be k then Loop will stop when 2^k &gt;=n Hence, we can calculate k 2^k=n k=log n Hence O(log n)</p>"},{"location":"time-and-space-complexity/time-complexity/#examples-recursive","title":"Examples - Recursive","text":""},{"location":"time-and-space-complexity/time-complexity/#example-1-fibonacci","title":"Example-1 | Fibonacci","text":"<p><pre><code>T(n)=k+T(n-1)  \nT(n-1)=k+T(n-2)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=k*n</p> <p>Hence, O(n)</p>"},{"location":"time-and-space-complexity/time-complexity/#example-2-binary-search","title":"Example-2 | Binary search","text":"<p><pre><code>T(n)=k+T(n/2)  \nT(n/2)=k+T(n/4)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=a(number of steps)* k</p> <p>Now, a= log n(which is number of steps) Hence, T(n) = k*log n</p> <p>Hence, O(log n)</p>"},{"location":"time-and-space-complexity/time-complexity/#example-3-merge-sort","title":"Example-3 | Merge sort","text":"<ul> <li>Break into 2 arrays, left and right</li> <li>Sort using recursion</li> <li>Merge into a new array (O(kn))</li> <li>Copy new array content to original array (O(kn))</li> </ul> <p><pre><code>T(n)=k+T(n/2)+T(n/2)+kn+kn  \nT(n)=2T(n/2)+kn  \n\n2T(n/2)=4T(n/4)+kn (multiplied both side by 2)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=a(number of steps)* nk</p> <p>Now, a= log n(which is number of steps) Hence, T(n) = nk*log n</p> <p>Hence, O(nlog n)</p>"},{"location":"time-and-space-complexity/time-complexity/#example-4-fibonacci","title":"Example-4 | Fibonacci","text":"<p><pre><code>T(n)=T(n-1)+T(n-2)\n\nForms a binary tree with n levels\n\nTotal nodes = 1+2^1+2^2+2^3+...2^n  \nEach node = k operation  \n\nT.C = k*Total nodes  \n    = k*((2^n+1)-1) [Formula]  \n    =k*2^n [approx]  \n</code></pre> Hence, O(2^n)</p>"}]}