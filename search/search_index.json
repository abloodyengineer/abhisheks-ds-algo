{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Another DS Algorithm Codebase","text":"<p>Mind-map (in progress...)</p> <p>Leetcode-the-hard-way</p>"},{"location":"1-Time-and-space-complexity/time-complexity/","title":"Time Complexity","text":"<p>The time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the input. Note that the time to run is a function of the length of the input and not the actual execution time of the machine on which the algorithm is running on.</p>"},{"location":"1-Time-and-space-complexity/time-complexity/#examples-iterative","title":"Examples - Iterative","text":"<p>Lets go through examples to understand the concepts.</p>"},{"location":"1-Time-and-space-complexity/time-complexity/#example-1-on","title":"Example-1 | O(n)","text":"<pre><code>for i in range(n):\n    print(i)\n</code></pre> <p>loop will run for 1+1+1+1+1+...n times = n. Hence O(n)</p>"},{"location":"1-Time-and-space-complexity/time-complexity/#example-2-on2","title":"Example-2 | O(n^2)","text":"<p><pre><code>for i in range(n):\n    for j in range(n):\n        print(i)\n</code></pre> Outer loop will run for 1+1+1+1+1+...n times = n Inner loop will run for 1+1+1+1+1+...n times = n As these are nested, total time = n^2 Hence O(n^2)</p>"},{"location":"1-Time-and-space-complexity/time-complexity/#example-3-olog-n","title":"Example-3 | O(log n)","text":"<p><pre><code>index=0\nsize = 129\nwhile index &lt; size:\n    print(index)\n    index *= 2\n</code></pre> loop will run for 12222*...k times = 2^k Complexity should be k then Loop will stop when 2^k &gt;=n Hence, we can calculate k 2^k=n k=log n Hence O(log n)</p>"},{"location":"1-Time-and-space-complexity/time-complexity/#examples-recursive","title":"Examples - Recursive","text":""},{"location":"1-Time-and-space-complexity/time-complexity/#example-1-fibonacci","title":"Example-1 | Fibonacci","text":"<p><pre><code>T(n)=k+T(n-1)  \nT(n-1)=k+T(n-2)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=k*n</p> <p>Hence, O(n)</p>"},{"location":"1-Time-and-space-complexity/time-complexity/#example-2-binary-search","title":"Example-2 | Binary search","text":"<p><pre><code>T(n)=k+T(n/2)  \nT(n/2)=k+T(n/4)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=a(number of steps)* k</p> <p>Now, a= log n(which is number of steps) Hence, T(n) = k*log n</p> <p>Hence, O(log n)</p>"},{"location":"1-Time-and-space-complexity/time-complexity/#example-3-merge-sort","title":"Example-3 | Merge sort","text":"<ul> <li>Break into 2 arrays, left and right</li> <li>Sort using recursion</li> <li>Merge into a new array (O(kn))</li> <li>Copy new array content to original array (O(kn))</li> </ul> <p><pre><code>T(n)=k+T(n/2)+T(n/2)+kn+kn  \nT(n)=2T(n/2)+kn  \n\n2T(n/2)=4T(n/4)+kn (multiplied both side by 2)  \n.  \n.  \n.  \nT(1)=k (Base condition)\n</code></pre> Adding everything above, we get  T(n)=a(number of steps)* nk</p> <p>Now, a= log n(which is number of steps) Hence, T(n) = nk*log n</p> <p>Hence, O(nlog n)</p>"},{"location":"1-Time-and-space-complexity/time-complexity/#example-4-fibonacci","title":"Example-4 | Fibonacci","text":"<p><pre><code>T(n)=T(n-1)+T(n-2)\n\nForms a binary tree with n levels\n\nTotal nodes = 1+2^1+2^2+2^3+...2^n  \nEach node = k operation  \n\nT.C = k*Total nodes  \n    = k*((2^n+1)-1) [Formula]  \n    =k*2^n [approx]  \n</code></pre> Hence, O(2^n)</p>"},{"location":"2-Sorting/1-selection-sort/","title":"Selection Sort","text":""},{"location":"2-Sorting/1-selection-sort/#intuition","title":"Intuition","text":"<ul> <li>Move minimum to front</li> <li>Loop through the list n times</li> <li>In each loop, take the i-th element as temp mini</li> <li>find the minimum in the array from i to n</li> <li>swap mini with i-th element</li> <li>continue by increasing i in each step</li> </ul>"},{"location":"2-Sorting/1-selection-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    # Selection sort- move min to front - O(n^2) - TLE\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        for i in range(n-1):\n            mini=i\n            for j in range(i,n):\n                if nums[j]&lt;nums[mini]:\n                    mini=j\n            self.swap(i,mini, nums)\n        return nums\n\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-Sorting/1-selection-sort/#time-complexity","title":"Time complexity","text":"<p>O(nlogn)</p>"},{"location":"2-Sorting/1-selection-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-Sorting/1-selection-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-Sorting/2-bubble-sort/","title":"Bubble Sort","text":""},{"location":"2-Sorting/2-bubble-sort/#intuition","title":"Intuition","text":"<ul> <li>Move maximun to end by adjacent swaps</li> <li>Loop i from end of list to beginning</li> <li>Loop j from 0 to i(dont include i)</li> <li>swap j with j+1 if j&gt;j+1, that is, moving the max to end</li> <li>after i goes from n-1 to 0, the array will be sorted</li> </ul>"},{"location":"2-Sorting/2-bubble-sort/#code","title":"Code","text":"<pre><code># Bubble sort- move max to end - O(n^2) - TLE\ndef sortArray(self, nums: List[int]) -&gt; List[int]:\n    n=len(nums)\n    for i in range(n-1,-1,-1):\n        for j in range(0, i):\n            if nums[j]&gt;nums[j+1]:\n                self.swap(j,j+1,nums)\n    return nums\ndef swap(self, first, second, nums):\n    temp=nums[first]\n    nums[first]=nums[second]\n    nums[second]=temp\n</code></pre> <pre><code>class Solution:\n    # Bubble sort- move max to end - little optimized - O(n^2), best case O(n) if array already sorted - TLE\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        for i in range(n-1,-1,-1):\n            swapped=0\n            for j in range(0, i):\n                if nums[j]&gt;nums[j+1]:\n                    self.swap(j,j+1,nums)\n                    swapped=1\n            if swapped==0:\n                return nums\n        return nums\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-Sorting/2-bubble-sort/#time-complexity","title":"Time complexity","text":"<p>O(N^2)</p>"},{"location":"2-Sorting/2-bubble-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-Sorting/2-bubble-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-Sorting/3-insertion-sort/","title":"Insertion Sort","text":""},{"location":"2-Sorting/3-insertion-sort/#intuition-opposite-of-bubble-sort","title":"Intuition - Opposite of Bubble sort","text":"<ul> <li>Move minimum to front by adjacent swaps</li> <li>Loop i from beginning to end of list</li> <li>Loop j from i to 0</li> <li>swap j with j-1 if nums[j]&lt; nums[j-1], that is, moving the min to beginning</li> <li>after i goes from 0 to n, the array will be sorted</li> </ul>"},{"location":"2-Sorting/3-insertion-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    # Insertion sort- bring lower value to beginning - compare each element with its left element, swap if element is smaller - O(n^2) - TLE\n    # Best case O(n)\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        for i in range(n):\n            for j in range(i,0,-1):\n                if nums[j]&lt;nums[j-1]:\n                    self.swap(j-1,j,nums)\n        return nums\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-Sorting/3-insertion-sort/#time-complexity","title":"Time complexity","text":"<p>O(N^2)</p>"},{"location":"2-Sorting/3-insertion-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-Sorting/3-insertion-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-Sorting/4-merge-sort/","title":"Merge Sort","text":""},{"location":"2-Sorting/4-merge-sort/#intuition","title":"Intuition","text":"<ul> <li>Calculate mid = (high+low)/2</li> <li>Call merge sort recursively from low to mid</li> <li>Call merge sort recursively from mid+1 to high</li> <li>Finally merge the two halves from low to high using mid</li> </ul>"},{"location":"2-Sorting/4-merge-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    # Merge-sort - O(nlogn)\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        n=len(nums)\n        self.mergeSort(nums,0, n-1)\n        return nums\n\n    def mergeSort(self, nums, low, high):\n        if low&gt;=high:\n            return\n        mid=(high+low)//2\n        self.mergeSort(nums, low, mid)\n        self.mergeSort(nums, mid+1, high)\n        self.merge(nums, low,mid,high)\n\n    def merge(self, nums, low,mid,high):\n        temp=[]\n        left=low\n        right=mid+1\n        while left&lt;=mid and right&lt;=high:\n            if nums[left]&lt;nums[right]:\n                temp.append(nums[left])\n                left+=1\n            else:\n                temp.append(nums[right])\n                right+=1\n        while left&lt;=mid:\n            temp.append(nums[left])\n            left+=1\n        while right&lt;=high:\n            temp.append(nums[right])\n            right+=1\n        for i in range(low,high+1):\n            nums[i]=temp[i-low]\n</code></pre>"},{"location":"2-Sorting/4-merge-sort/#time-complexity","title":"Time complexity","text":"<p>O(nlogn)</p>"},{"location":"2-Sorting/4-merge-sort/#space-complexity","title":"Space Complexity","text":"<p>O(n) + recursion stack Additional space is required for the temporary array used during merging.</p>"},{"location":"2-Sorting/4-merge-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"2-Sorting/5-quick-sort/","title":"Quick Sort","text":"<p>Not suitable if array is sorted</p>"},{"location":"2-Sorting/5-quick-sort/#intuition","title":"Intuition","text":"<ul> <li>Call pivot which appoints a pivot, moves everything smaller than pivot to left and larger to right of pivot. move the pivot to the correct place. Return the pivot index</li> <li>Call quick sort recursively again from low to pivot_index-1</li> <li>Call quick sort recursively again from pivot_index+1 to high</li> <li>Pivot function:<ul> <li>take the low index as pivot</li> <li>i=low, j=high</li> <li>while i &lt;= high, and nums[i] &lt;= pivot, increment i</li> <li>while j&gt;=low , and nums[j] &gt; pivot, decrement j</li> <li>What this means is we stop i when i is at an index whose value is higher than pivot and j at an index whose value is smaller than equal to pivot.</li> <li>if i and j did not cross, we can swap i and j so that smaller is at left, larger is at right</li> <li>if i and j cross each other, means we have done all movement, now we can place the pivot in its correct index.</li> <li>correct index of pivot will be j as it stands at one place left of the index which is just higher than pivot</li> <li>so, swap low(pivot index) with j</li> <li>also return j as the pivot index, so that next recursion calls can be from 0 to j-1 and j+1 to end, that is excluding j</li> </ul> </li> </ul>"},{"location":"2-Sorting/5-quick-sort/#code","title":"Code","text":"<pre><code>class Solution:\n    def sortColors(self, nums: List[int]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        self.quick_sort(nums,0,n-1)\n\n    def quick_sort(self, nums, low,high):\n        if low&lt;high:\n\n            pivot_index=self.pivot(nums,low,high)\n            self.quick_sort(nums,low,pivot_index-1)\n            self.quick_sort(nums,pivot_index+1, high)\n\n    def pivot(self, nums, low, high):\n        pivot =nums[low]\n        i=low\n        j=high\n        while i&lt;j:\n            while i&lt;=high and nums[i]&lt;=pivot: #less than equal to to consider the equal to scenario\n                i+=1\n            while j&gt;=low and nums[j]&gt;pivot: #just greater than as equal to scenario checked above already\n                j-=1\n            if i&lt;j:\n                self.swap(i,j,nums)\n        self.swap(low,j, nums)\n        return j\n\n\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"2-Sorting/5-quick-sort/#time-complexity","title":"Time complexity","text":"<p>O(nlogn)</p>"},{"location":"2-Sorting/5-quick-sort/#space-complexity","title":"Space Complexity","text":"<p>O(1)</p>"},{"location":"2-Sorting/5-quick-sort/#study-further","title":"Study Further","text":"<ul> <li>Geek For Geeks</li> </ul>"},{"location":"3-Array/1-second-largest-element-in-array/","title":"Second largest element in array","text":"<p>Problem link - GFG</p>"},{"location":"3-Array/1-second-largest-element-in-array/#intuition","title":"Intuition","text":"<ul> <li>initialize largest1 and largest2</li> <li>Loop through array</li> <li>if you get an element greater than largest1, make largest2 = largest 1 now, and largest1 = arr[i]</li> <li>else, if element is greater than largest2, make largest2=arr[i]</li> </ul> <pre><code>class Solution:\n    def print2largest(self,arr, n):\n        # code here\n        largest1=arr[0]\n        largest2=-1\n        for i in range(1,n):\n            if arr[i]&gt;largest1:\n                largest2=largest1\n                largest1=arr[i]\n            elif arr[i]&lt;largest1 and arr[i]&gt;largest2:\n                largest2=arr[i]\n        return largest2\n</code></pre>"},{"location":"3-Array/2-remove-duplicates-from-sorted-array/","title":"Remove duplicates from sorted array","text":"<p>Problem link - Leetcode</p>"},{"location":"3-Array/2-remove-duplicates-from-sorted-array/#intuition-brute-force-using-set","title":"Intuition - Brute force - using set","text":"<p>Time complexity - O(nlogn)</p> <p>Space complexity - O(n) for set</p> <ul> <li>store nums in a set and sort it. make sure tor assign this to nums</li> <li>return the length of nums, which is now a set</li> </ul> <pre><code>class Solution:\n    def removeDuplicates(self, nums: List[int]) -&gt; int:\n        nums[:]=sorted(set(nums))\n        return len(nums)\n</code></pre>"},{"location":"3-Array/2-remove-duplicates-from-sorted-array/#intuition-optimal-force-using-two-pointers","title":"Intuition - Optimal force - using two pointers","text":"<p>Time complexity - O(n)</p> <p>Space complexity - O(1)</p> <ul> <li>take left = 0, right = 0</li> <li>loop right from 0 to n</li> <li>if nums[right] is not equal to nums[left], assign nums[right] nums[left+1] and increment left by 1. This means, when we fin a new element, we place it next to first occurence of old element</li> <li>length of unique elements will be left+1</li> </ul> <pre><code>class Solution:\n    # Optimal approach - 2 pointers - time - O(n) - space - O(1)\n    def removeDuplicates(self, nums: List[int]) -&gt; int:\n        n=len(nums)\n        left=0\n        right=0\n        while right &lt; n:\n            if nums[right] != nums[left]:\n                nums[left+1]=nums[right]\n                left+=1\n            right+=1\n        return left+1\n</code></pre>"},{"location":"3-Array/3-left-rotate-an-array-by-1-place/","title":"Left rotate an array by 1 place","text":"<p>Problem link - Leetcode</p>"},{"location":"3-Array/3-left-rotate-an-array-by-1-place/#intuition","title":"Intuition","text":"<p>Time complexity - O(n)</p> <p>Space complexity - O(1)</p> <ul> <li>store first element in a temp variable</li> <li>loop through array from 1 to n</li> <li>place 1st index in 0th, 2nd in 1st...so on</li> <li>place temp in last index</li> </ul> <pre><code>Easy\n</code></pre>"},{"location":"3-Array/4-right-rotate-an-array-by-k-place/","title":"Left rotate an array by k places","text":"<p>Problem link - Leetcode</p>"},{"location":"3-Array/4-right-rotate-an-array-by-k-place/#intuition-1-using-temp-array","title":"Intuition 1 - using temp array","text":"<p>Time complexity - O(n+d)</p> <p>Space complexity - O(N)</p> <ul> <li>store last k elements in a temp array</li> <li>loop through array from end to k</li> <li>move elements from 0 to n-k to end</li> <li>fill up starting k places with elements from temp</li> </ul> <pre><code>class Solution:\n    # Time -O(n+d) Extra Space - O(N)\n    def rotate(self, nums: List[int], k: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        new_k=k%n\n        temp=nums[n-new_k:n]\n        for i in range(n-1,new_k-1,-1):\n            nums[i]=nums[i-new_k]\n        for i in range(len(temp)):\n            nums[i]=temp[i]\n</code></pre>"},{"location":"3-Array/4-right-rotate-an-array-by-k-place/#intuition-2-using-reversing-technique","title":"Intuition 2 - using reversing technique","text":"<p>Time complexity - O(n)</p> <p>Space complexity - O(1)</p> <ul> <li>Reverse 0 to n-k</li> <li>Reverse n-k to end</li> <li>Reverse 0 to end</li> </ul> <pre><code>class Solution:\n    # time - O(N) extra space - O(1) \n    def rotate(self, nums: List[int], k: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        new_k=k%n\n        self.reverse(0, n-new_k, nums)\n        self.reverse(n-new_k, n, nums)\n        self.reverse(0,n,nums)\n    def reverse(self, left, right,nums):\n        while left&lt;right-1:\n            temp=nums[left]\n            nums[left]=nums[right-1]\n            nums[right-1]=temp\n            left+=1\n            right-=1\n</code></pre>"},{"location":"3-Array/5-move-zeroes-to-end/","title":"Move zeroes to end","text":"<p>Problem link - Leetcode</p>"},{"location":"3-Array/5-move-zeroes-to-end/#intuition-1-optimal","title":"Intuition 1 - optimal","text":"<p>Time complexity - O(n)</p> <p>Space complexity - O(1)</p> <ul> <li>initialize a variable zero_index with 0</li> <li>loop through array from 0 to end</li> <li>if element is non zero, swap it with the last zero_index</li> <li>increment zero_index as zero moved to the right by one place due to swap</li> <li>slowly all non zeros will move to left and all zeros to end</li> </ul> <pre><code>class Solution:\n    def moveZeroes(self, nums: List[int]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        zero_index=0\n        for i in range(n):\n            if nums[i]!=0:\n                self.swap(i,zero_index, nums)\n                zero_index+=1\n\n    def swap(self, first, second, nums):\n        temp=nums[first]\n        nums[first]=nums[second]\n        nums[second]=temp\n</code></pre>"},{"location":"3-Array/6-find-missing-number/","title":"Move zeroes to end","text":"<p>Problem link - Leetcode</p>"},{"location":"3-Array/6-find-missing-number/#intuition-1-good-solution","title":"Intuition 1 - Good solution","text":"<p>Time complexity - O(2n)</p> <p>Space complexity - O(n)</p> <ul> <li>initialize a temp array with all 0s</li> <li>loop through the nums array, and mark the indexes corresponding to the elements with 1, i.e, if 2 is present in nums, mark arr[2]=1 and so on</li> <li>loop through temp array. whichever index is marked 0 is the missing number</li> </ul> <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        n=len(nums)\n        arr=[0]*(n+1)\n        for i in range(n):\n            arr[nums[i]]=1\n        for i in range(n+1):\n            if arr[i]==0:\n                return i\n</code></pre>"},{"location":"3-Array/6-find-missing-number/#intuition-2-optimal-solution-1-sum","title":"Intuition 2 - Optimal solution 1 - sum","text":"<p>Time complexity - O(n)</p> <p>Space complexity - O(1)</p> <ul> <li>Find sum on first n natural numbers</li> <li>find sum of given nums array</li> <li>the difference is the missing number</li> </ul> <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        n=len(nums)\n        nsum=sum(range(n+1))\n        actual_sum=sum(nums)\n        return nsum-actual_sum\n</code></pre>"},{"location":"3-Array/6-find-missing-number/#intuition-3-optimal-solution-2-xor","title":"Intuition 3 - Optimal solution 2 - xor","text":"<p>This can be solved using xor as well. Hint - Xor with first n natural numbers. the answer is the missing number because a^a=0</p> <p>so every number cancels out except the missing number</p>"},{"location":"3-Array/longest-sub-array-with-sum-k/","title":"Longest Sub-Array with Sum K","text":"<p>Problem link - GFG</p>"},{"location":"3-Array/longest-sub-array-with-sum-k/#only-positives","title":"Only positives","text":""},{"location":"3-Array/longest-sub-array-with-sum-k/#intuition-better-approach-using-hashmap","title":"Intuition - Better approach using hashmap","text":"<p>Time complexity - O(nlogn) n for loop, logn to find in hashmap</p> <p>Space complexity - O(n) for hashmap</p> <ul> <li>create a hashmap, we will store cumulative sum until i as key, and i as value, in hashmap</li> <li>Loop through array using i</li> <li>keep a cumulative sum of elements up to i</li> <li>if sum == k, then max_len should be equal to max of previous max_len and current length, i.e, i+1</li> <li>But if it is not equal to k, check if sum-k exists in the hashmap. This means, check if there exists a sum already in the array which, if removed, will make another subarray sum to be equal to k</li> <li>if it exists, then max_len should be equal to max of previous max_len and length of subarray from index computed in previous step to i. index of previous step in already stored in hashmap</li> <li>At the end, store the current cumulative sum in hashmap with current i as value to be retrieved later to perform above steps</li> </ul> <pre><code>class Solution:\n    def lenOfLongSubarr (self, arr, n, k) : \n        #Complete the function\n        mp={}\n        max_len=0\n        sums=0\n        for i in range(n):\n            sums+=arr[i]\n            if sums==k:\n                max_len=max(max_len,i+1)\n            elif sums-k in mp:\n                max_len=max(max_len, i-mp[sums-k])\n            if sums not in mp:\n                mp[sums]=i\n        return max_len\n</code></pre>"},{"location":"3-Array/longest-sub-array-with-sum-k/#intuition-optimal-approach-using-two-pointers-prefix-sum","title":"Intuition - Optimal approach using two pointers, prefix sum","text":"<p>Could not test this as no problem with only positives</p> <p>Time complexity - O(2n) inner while will run max for n times in whole program run</p> <p>Space complexity - O(1)</p> <ul> <li>Loop through array using i</li> <li>keep a cumulative sum of elements up to i</li> <li>if sum == k, then max_len should be equal to max of previous max_len and current length, i.e, i+1</li> <li>Otherwise, we need to move to next i. But before that, check if sums is greater than k. If yes, keep removing element from j from sum until it is smaller than k.</li> <li>At the end, return max_len</li> </ul> <pre><code>class Solution:\n    def lenOfLongSubarr (self, arr, n, k):\n        max_len=0\n        sums=0\n        j=0\n        for i in range(n):\n            sums+=arr[i]\n            if sums==k:\n                max_len=max(max_len,i-j+1)\n            while j&lt;i and  sums&gt;k:\n                sums-=arr[j]\n                j+=1\n        return max_len\n</code></pre>"},{"location":"3-Array/longest-sub-array-with-sum-k/#with-positives-negatives-and-zeros","title":"With positives, negatives and zeros","text":""},{"location":"3-Array/longest-sub-array-with-sum-k/#intuition-optimal","title":"Intuition - Optimal","text":"<p>Time complexity - O(nlogn) n for loop, logn to find in hashmap</p> <p>Space complexity - O(n) for hashmap</p> <ul> <li>create a hashmap, we will store cumulative sum until i as key, and i as value, in hashmap</li> <li>Loop through array using i</li> <li>keep a cumulative sum of elements up to i</li> <li>if sum == k, then max_len should be equal to max of previous max_len and current length, i.e, i+1</li> <li>But if it is not equal to k, check if sum-k exists in the hashmap. This means, check if there exists a sum already in the array which, if removed, will make another subarray sum to be equal to k</li> <li>if it exists, then max_len should be equal to max of previous max_len and length of subarray from index computed in previous step to i. index of previous step in already stored in hashmap</li> <li>At the end, store the current cumulative sum in hashmap with current i as value to be retrieved later to perform above steps</li> </ul> <pre><code>class Solution:\n    def lenOfLongSubarr (self, arr, n, k) : \n        #Complete the function\n        mp={}\n        max_len=0\n        sums=0\n        for i in range(n):\n            sums+=arr[i]\n            if sums==k:\n                max_len=max(max_len,i+1)\n            elif sums-k in mp:\n                max_len=max(max_len, i-mp[sums-k])\n            if sums not in mp:\n                mp[sums]=i\n        return max_len\n</code></pre>"},{"location":"4-Binary-search/1-binary-search/","title":"Binary Search","text":""},{"location":"4-Binary-search/1-binary-search/#iterative","title":"Iterative","text":"<pre><code>class Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        n=len(nums)\n        low=0\n        high=n-1\n        while low&lt;=high:\n            mid=(low+high)//2\n            if nums[mid]==target:\n                return mid\n            elif nums[mid]&lt;target:\n                low=mid+1\n            else:\n                high=mid-1\n        return -1\n</code></pre>"},{"location":"5-Recursion/1-subsets-1/","title":"Subsets - 1 - Elements are unique and ans cannot contain duplicates","text":""},{"location":"5-Recursion/1-subsets-1/#intuition","title":"Intuition","text":"<ul> <li>Start off with empty array</li> <li>Recursively solve by either selecting a number or not</li> <li>Base condition - ind&gt;n</li> </ul>"},{"location":"5-Recursion/1-subsets-1/#example","title":"Example","text":"<p>Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p> <pre><code>class Solution:\n    def subsets(self, nums: List[int]) -&gt; List[List[int]]:\n        arr=[]\n        ans=[]\n        ind=0\n        n=len(nums)\n        self.solve(nums, arr, ind,n,ans)\n        return ans\n\n    def solve(self, nums ,arr, ind, n, ans):\n        if ind&gt;=n:\n            ans.append(arr.copy())\n            return\n        arr.append(nums[ind])\n        self.solve(nums, arr, ind+1, n, ans)\n        arr.pop()\n        self.solve(nums, arr, ind+1, n, ans)\n</code></pre>"},{"location":"5-Recursion/2-subsets-2/","title":"Subsets - 2 - Array nums that may contain duplicates, ans cannot have duplicates","text":""},{"location":"5-Recursion/2-subsets-2/#intuition","title":"Intuition","text":"<ul> <li>As there might be duplicates, sort the array to group duplicates</li> <li>we will start off with an empty array and put that in ans array</li> <li>we will loop through each element, and put it in ans array if not duplicate</li> <li>if duplicate, continue</li> </ul>"},{"location":"5-Recursion/2-subsets-2/#example","title":"Example","text":"<p>Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]</p> <pre><code>class Solution:\n    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: \n        nums.sort()\n        n=len(nums)\n        ans=[]\n        ind=0\n        self.solve(nums, [], ind, n, ans )\n        return ans\n\n    def solve(self, nums, arr, ind, n, ans):\n        print(ind,arr)\n        ans.append(arr.copy())\n        for i in range(ind,n):\n            if i!=ind and nums[i]==nums[i-1]:\n                continue\n            arr.append(nums[i])\n            # here it is i+1 and not ind+1 as we are moving to the next i. This is ind in permutation 1\n            self.solve(nums, arr, i+1, n, ans)\n            arr.pop()\n</code></pre>"},{"location":"5-Recursion/3-permutations/","title":"Permutations","text":""},{"location":"5-Recursion/3-permutations/#intuition","title":"Intuition","text":"<ul> <li>loop through each element in array</li> <li>swap that element in ind with everything from ind to n using i variable</li> </ul>"},{"location":"5-Recursion/3-permutations/#example","title":"Example","text":"<p>Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p> <pre><code>class Solution:\n    def permute(self, nums: List[int]) -&gt; List[List[int]]:\n        n=len(nums)\n        ans=[]\n        ind=0\n        self.solve(nums, ind, n, ans)\n        return ans\n\n    def solve(self, nums,ind,n,ans):\n        if ind==n:\n            ans.append(nums.copy())\n            return\n\n        for i in range(ind,n):\n            # swapping from current index ind to n\n            self.swap(nums,ind,i)\n            # ind+1 because we are moving to the next index to start swapping from ind to n\n            self.solve(nums, ind+1, n, ans)\n            # backtrack\n            self.swap(nums,ind,i)\n    def swap(self, nums, ind,i):\n        temp=nums[ind]\n        nums[ind]=nums[i]\n        nums[i]=temp\n</code></pre>"},{"location":"6-Graph/1-Bfs-Dfs/10-bipartite/","title":"Is graph bipartite","text":"<p>Concept - Bipartite can be checked by coloring approach. colour alternate nodes with 2 different colours. if no two nodes have same colour, graph is bipartite, else not.</p> <p>Problem link - Leetcode</p>"},{"location":"6-Graph/1-Bfs-Dfs/10-bipartite/#intuition","title":"Intuition","text":"<ul> <li>Can be solved using both DFS and BFS</li> <li>Keep multiple components in mind</li> <li>Using Bfs- assign all neighbouring nodes opposite colour. If at any point any neighbouring node has same colour, we can return False</li> <li>in for loop for multiple components, check if false, return false. At the end, return True</li> </ul> <pre><code>from collections import deque\nclass Solution:\n    def isBipartite(self, graph: List[List[int]]) -&gt; bool:\n\n        n=len(graph)\n        vis=[-1 for _ in range(n)]\n        for i in range(n):\n            if vis[i]==-1:\n                if self.check(i, vis, graph) ==False:\n                    return False\n        return True\n\n    def check(self,start, vis, graph):\n        q=deque()\n        q.append((start,0))\n        vis[start]=0\n        while q:\n            node,color=q.popleft()\n            newColor=int(not color)\n            for it in graph[node]:\n                if vis[it] == color:\n                    return False\n                if vis[it] ==-1:\n                    vis[it]=newColor\n                    q.append((it,newColor))\n        return True          \n</code></pre>"},{"location":"6-Graph/1-Bfs-Dfs/3-number-of-provinces/","title":"Number of Provinces","text":"<p>Concept - count number of components using a for and vis array </p> <p>Problem link - Leetcode</p>"},{"location":"6-Graph/1-Bfs-Dfs/3-number-of-provinces/#intuition","title":"Intuition","text":"<ul> <li>Create adjacency list. Undirected so need to append both i and j</li> <li>Keep looping through all the vertices and putting them in visited array using DFS</li> <li>Everytime we find a new vertex which is not in DFS means it is not in a cycle hence it is a new component</li> <li>keep counting and return cnt</li> </ul> <pre><code>class Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -&gt; int:\n\n        n=len(isConnected)\n\n        adjLst={}\n\n        for i in range(n):\n            for j in range(n):\n                if isConnected[i][j]==1:\n                    if i in adjLst:\n                        adjLst[i].append(j)\n                    else:\n                        adjLst[i]=[j]\n                    if j in adjLst:\n                        adjLst[j].append(i)\n                    else:\n                        adjLst[j]=[i]\n        vis=[0]*n\n        cnt=0\n        for i in range(n):\n            if vis[i]!=1:\n                cnt+=1\n                self.dfs(adjLst,vis,i)\n        return cnt\n    def dfs(self, adjLst, vis,node):\n        vis[node] =1\n        for it in adjLst[node]:\n            if vis[it] !=1:\n                self.dfs(adjLst, vis,it)\n</code></pre>"},{"location":"6-Graph/1-Bfs-Dfs/4-rotting-oranges/","title":"Rotting oranges","text":"<p>Concept - Time taken to do something - BFS using a time counter. Increment time counter while pushing to queue</p> <p>Problem link - Leetcode</p>"},{"location":"6-Graph/1-Bfs-Dfs/4-rotting-oranges/#intuition","title":"Intuition","text":"<ul> <li>Find all rotten oranges and push its index to queue along with time =0</li> <li>Maintain drow dcol</li> <li>Maintain an ans_time which is the final time</li> <li>Keep ading neighbouring good oranges to vis to track what good oranges have been marked bad</li> <li>Loop through grid and return -1 if some good orange still left, else retutn ans_time</li> </ul> <pre><code>from collections import deque\nclass Solution:\n    def orangesRotting(self, grid: List[List[int]]) -&gt; int:\n        m=len(grid)\n        n=len(grid[0])\n        q=deque()\n        vis=[[None for _ in range(n+1)] for _ in range(m+1)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]==2:\n                    q.append((i,j,0))\n                    vis[i][j]=2\n        drow=[0,-1,0,1]\n        dcol=[-1,0,1,0]\n        ans_time=0\n        while q:\n            row,col,time=q.popleft()\n            ans_time=max(ans_time,time)\n            for i in range(4):\n                nrow=row+drow[i]\n                ncol=col+dcol[i]\n                if nrow&gt;=0 and nrow&lt;m and ncol&gt;=0 and ncol&lt;n and grid[nrow][ncol] ==1 and vis[nrow][ncol]!=2:\n                    q.append((nrow,ncol,time+1))\n\n                    vis[nrow][ncol]=2\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]==1 and vis[i][j]!=2:\n                    return -1\n        return ans_time    \n</code></pre>"},{"location":"6-Graph/1-Bfs-Dfs/5-flood-fill/","title":"Flood Fill","text":"<p>Concept - DFS to fill up colour</p> <p>Problem link - Leetcode</p>"},{"location":"6-Graph/1-Bfs-Dfs/5-flood-fill/#intuition","title":"Intuition","text":"<ul> <li>Maintain drow dcol</li> <li>store initial colour in sr,sc</li> <li>Do a dfs</li> <li>Call dfs recursively if the neighbour is having ini colour and is not equal the final colour</li> <li>return the grid(image)</li> </ul> <pre><code>class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -&gt; List[List[int]]:\n        drow=[-1,0,1,0]\n        dcol=[0,-1,0,1]\n        m=len(image)\n        n=len(image[0])\n        ini=image[sr][sc]\n        self.dfs(image,sr,sc,color,drow,dcol,m,n,ini)\n        return image\n\n    def dfs(self, image,row,col,color,drow,dcol,m,n,ini):\n        image[row][col]=color\n        for i in range(4):\n            nrow=row+drow[i]\n            ncol=col+dcol[i]\n            if nrow&gt;=0 and nrow&lt;m and ncol&gt;=0 and ncol&lt;n and image[nrow][ncol]==ini and image[nrow][ncol]!=color:\n                self.dfs(image,nrow,ncol,color,drow,dcol,m,n,ini)\n</code></pre>"},{"location":"6-Graph/1-Bfs-Dfs/6-cycle-detection/","title":"Flood Fill","text":"<p>Concept - To detect cycle, pass parent and keep marking visited array. If we encounter that visisted array is already marked for one element, and its not the parent element, we can say it is a cycle. Can use both DFS and BFS</p>"},{"location":"6-Graph/1-Bfs-Dfs/6-cycle-detection/#intuition","title":"Intuition","text":"<ul> <li>Maintain drow dcol</li> <li>store initial colour in sr,sc</li> <li>Do a dfs</li> <li>Call dfs recursively if the neighbour is having ini colour and is not equal the final colour</li> <li>return the grid(image)</li> </ul> <pre><code>class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -&gt; List[List[int]]:\n        drow=[-1,0,1,0]\n        dcol=[0,-1,0,1]\n        m=len(image)\n        n=len(image[0])\n        ini=image[sr][sc]\n        self.dfs(image,sr,sc,color,drow,dcol,m,n,ini)\n        return image\n\n    def dfs(self, image,row,col,color,drow,dcol,m,n,ini):\n        image[row][col]=color\n        for i in range(4):\n            nrow=row+drow[i]\n            ncol=col+dcol[i]\n            if nrow&gt;=0 and nrow&lt;m and ncol&gt;=0 and ncol&lt;n and image[nrow][ncol]==ini and image[nrow][ncol]!=color:\n                self.dfs(image,nrow,ncol,color,drow,dcol,m,n,ini)\n</code></pre>"},{"location":"6-Graph/1-Bfs-Dfs/8-surrounded-regions/","title":"Surrounded Regions","text":"<p>Concept - Start from all boundaries and trace neighbours using DFS.</p> <p>Problem link - Leetcode</p>"},{"location":"6-Graph/1-Bfs-Dfs/8-surrounded-regions/#intuition","title":"Intuition","text":"<ul> <li>Check each boundary for \"O\". If it has not been visited already, start DFS from there</li> <li>Logic is, if we find an \"O\" at the boundary and find all its connected neighbours, we can definitely say those \"O\"s cannot be converted to \"X\" as they have a boundary \"O\"</li> </ul> <pre><code>class Solution:\n    def solve(self, board: List[List[str]]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        m=len(board)\n        n=len(board[0])\n        vis=[[0 for _ in range(n)] for _ in range(m)]\n        drow=[-1,0,1,0]\n        dcol=[0,-1,0,1]\n        for i in range(m):\n            if board[i][0]==\"O\" and vis[i][0]!=1:\n                self.dfs(board,i,0,vis, drow, dcol, m,n)\n            if board[i][n-1]==\"O\" and vis[i][n-1]!=1:\n                self.dfs(board,i,n-1,vis, drow, dcol, m,n)\n        for i in range(n):\n            if board[0][i]==\"O\" and vis[0][i]!=1:\n                self.dfs(board,0,i,vis, drow, dcol, m,n)\n            if board[m-1][i]==\"O\" and vis[m-1][i]!=1:\n                self.dfs(board,m-1,i,vis, drow, dcol, m,n)\n\n        for i in range(m):\n            for j in range(n):\n                if board[i][j]==\"O\" and vis[i][j]!=1:\n                    board[i][j]=\"X\"\n        return board\n\n    def dfs(self, board, r,c,vis, drow, dcol, m,n):\n        vis[r][c]=1\n        for i in range(4):\n            nrow=r+drow[i]\n            ncol=c+dcol[i]\n\n            if nrow&gt;=0 and nrow&lt;m and ncol&gt;=0 and ncol&lt;n and board[nrow][ncol]==\"O\" and vis[nrow][ncol]!=1:\n                self.dfs(board,nrow,ncol,vis, drow, dcol, m,n)             \n</code></pre>"},{"location":"6-Graph/1-Bfs-Dfs/9-number-of-distinct-islands/","title":"Number of Distinct islands","text":"<p>Concept - start DFS from all 1 and store index-source in a set. This makes sure we eliminate similar pattern of 1s</p> <p>Problem link - YouTube</p>"},{"location":"6-Graph/2-Cycle-detection/1-undirected-bfs/","title":"Cycle Detection - Undirected - BFS","text":"<p>Concept - To detect cycle, pass parent and keep marking visited array. If we encounter that visisted array is already marked for one element, and its not the parent element, we can say it is a cycle. Can use both DFS and BFS</p> <p>Problem link - GFG</p> <pre><code>from typing import List\nfrom collections import deque\nclass Solution:\n    #Function to detect cycle in an undirected graph.\n    def isCycle(self, V: int, adj: List[List[int]]) -&gt; bool:\n        #Code here\n        vis=[0 for _ in range(V)]\n        for i in range(V):\n            if vis[i] ==0:\n                if self.solve(i,adj,vis) == True:\n                    return True\n        return False\n\n    def solve(self,node, adj,vis):\n        q=deque()\n        q.append((node,-1))\n\n        while q:\n            el,parent = q.popleft()\n            vis[el]=1\n            for it in adj[el]:\n                if vis[it]==1 and it!=parent:\n                    return True\n                if vis[it]==0:\n                    q.append((it,el))\n                    vis[it]=1\n        return False\n</code></pre>"},{"location":"6-Graph/2-Cycle-detection/2-undirected-dfs/","title":"Cycle Detection - Undirected - DFS","text":"<p>Concept - To detect cycle, pass parent and keep marking visited array. If we encounter that visisted array is already marked for one element, and its not the parent element, we can say it is a cycle. Can use both DFS and BFS</p> <p>Problem link - GFG</p>"},{"location":"6-Graph/2-Cycle-detection/2-undirected-dfs/#notice","title":"Notice","text":"<pre><code>if self.dfs(it,node, adj, vis )==True:\n    return True\n</code></pre> <p>This is very important to return from DFS any time we get True. Otherwise DFS will continue and return False</p>"},{"location":"6-Graph/2-Cycle-detection/2-undirected-dfs/#code","title":"Code","text":"<pre><code>from typing import List\nclass Solution:\n    #Function to detect cycle in an undirected graph\n    def isCycle(self, V: int, adj: List[List[int]]) -&gt; bool:\n        #Code here\n        # DFS\n        vis=[0 for _ in range(V)]\n        for i in range(V):\n            if vis[i] ==0:\n                if self.dfs(i,-1,adj,vis) == True:\n                    return True\n        return False\n\n    def dfs(self,node,parent, adj,vis):\n        vis[node]=1\n        for it in adj[node]:\n            if vis[it]==1 and it!=parent:\n                return True\n            if vis[it]==0:\n\n                if self.dfs(it,node, adj, vis )==True:\n                    return True\n        return False\n</code></pre>"},{"location":"6-Graph/2-Cycle-detection/3-directed-dfs/","title":"Cycle Detection - directed - DFS","text":"<p>Concept - To detect cycle in a directed graph, we need to keep track of a pathVisited array instead of parent. Then during DFS, we need to mark both vis and pathVis array. When we encounter a node with both vis and pathVis set to 1, we can conclude that this node has already been visited along the same path, hence cycle. If we do not see any such instance, we need to backtrack, that is mark pathVis for that node to 0.</p> <p>Problem link - GFG</p>"},{"location":"6-Graph/2-Cycle-detection/3-directed-dfs/#notice","title":"Notice","text":"<pre><code>if self.dfs(it, adj, vis,pathVis )==True:\n    return True\n</code></pre> <p>This is very important to return from DFS any time we get True. Otherwise DFS will continue and return False</p> <p>DFS works as we need to backtrack. To do BFS, we need a different approach(Topo sort)</p>"},{"location":"6-Graph/2-Cycle-detection/3-directed-dfs/#code","title":"Code","text":"<pre><code>from typing import List\nclass Solution:\n    #Function to detect cycle in a directed graph.\n    def isCyclic(self, V : int , adj : List[List[int]]) -&gt; bool :\n        # code here\n        vis=[0 for _ in range(V)]\n        pathVis=[0 for _ in range(V)]\n        for i in range(V):\n            if vis[i] ==0:\n                if self.dfs(i,adj,vis, pathVis) == True:\n                    return True\n        return False\n\n    def dfs(self,node, adj,vis, pathVis):\n        vis[node]=1\n        pathVis[node]=1\n        for it in adj[node]:\n            if vis[it]==1 and pathVis[it]==1:\n                return True\n            if vis[it]==0:\n                if self.dfs(it, adj, vis,pathVis )==True:\n                    return True\n        pathVis[node]=0\n        return False\n</code></pre>"},{"location":"6-Graph/2-Cycle-detection/4-topo-sort-dfs/","title":"Topo Sort - DFS","text":"<p>Concept - In a topological sort, for every directed edge u -&gt; v,  u must come before v in the ordering.</p> <p>Problem link - GFG</p>"},{"location":"6-Graph/2-Cycle-detection/4-topo-sort-dfs/#intuition","title":"Intuition","text":"<ul> <li>Take a stack</li> <li>Add nodes to stack using DFS, only whiile returning back from the node</li> <li>Explanation for above point - Only append to stack after all DFS calls for a particular node is over</li> <li>To get the topo sort, pop from the top of stack and push to ans array. ans array is the topo sort</li> <li>logic- if we put node to stack after all dfs calls for that node is done, we can make sure that there is no nodes unvisited to the right of the current node. Hence present position is the correct position for the node in the topo sort and <code>for every directed edge u -&gt; v,  u must come before v in the ordering</code> - This holds</li> </ul>"},{"location":"6-Graph/2-Cycle-detection/4-topo-sort-dfs/#code","title":"Code","text":"<pre><code>class Solution:\n    #Function to return list containing vertices in Topological order.\n    def topoSort(self, V, adj):\n        # Code here\n        stack=[]\n        vis=[0 for _ in range(V)]\n        ans=[]\n        for i in range(V):\n            if vis[i]==0:\n                self.dfs(i,adj, stack, vis)\n        while stack:\n            ans.append(stack.pop())\n        return ans\n\n    def dfs(self,node, adj, stack, vis):\n        vis[node]=1\n        for it in adj[node]:\n            if vis[it]!=1:\n                self.dfs(it, adj, stack, vis)\n        stack.append(node)\n</code></pre>"},{"location":"6-Graph/2-Cycle-detection/5-topo-sort-bfs-kahns/","title":"Topo Sort - BFS - Kahn's Algorithm","text":"<p>Concept - In a topological sort, for every directed edge u -&gt; v,  u must come before v in the ordering.</p> <p>Problem link - GFG</p>"},{"location":"6-Graph/2-Cycle-detection/5-topo-sort-bfs-kahns/#intuition","title":"Intuition","text":"<ul> <li>Take a queue</li> <li>Take a indegree array</li> <li>Fill indegree with indegrees of each node</li> <li>Put every node with indegree 0 to queue. We will always have atleast one node with indegree 0 as it is a acyclic graph</li> <li>While queue is not empty, pop the frontmost node.</li> <li>Add this node to the topo sort ans array. As indegree of node is 0, we can straight away add it to topo as it cannot have any incoming edge</li> <li>After adding the node, relax all the indegrees of the neighbouring nodes</li> <li>If after relaxation, any neighbouring node has indegree 0, put it in the queue</li> <li>return topo once queue is empty</li> </ul>"},{"location":"6-Graph/2-Cycle-detection/5-topo-sort-bfs-kahns/#code","title":"Code","text":"<pre><code>from collections import deque\nclass Solution:\n    #Function to return list containing vertices in Topological order.\n    def topoSort(self, V, adj):\n        # Code here/\n        # Kahns algo -BFS\n        indegree=[0]*V\n        for i in range(V):\n            for it in adj[i]:\n                indegree[it]+=1\n        q=deque()\n        for i in range(V):\n            if indegree[i]==0:\n                q.append(i)\n        topo=[]\n        while q:\n            node=q.popleft()\n            # As indegree of node is 0, we can straight away add it to topo as it cannot have any incoming edge\n            topo.append(node)\n            # As we already added the node in the topot sort, we can relax indegree for the neighbouring nodes by 1\n            for it in adj[node]:\n                indegree[it]-=1\n                if indegree[it]==0:\n                    q.append(it)\n        return topo\n</code></pre>"},{"location":"6-Graph/2-Cycle-detection/6-directed-bfs-kahns/","title":"Cycle Detection - directed - DFS","text":"<p>Concept - If topo sort using kahns algo works, it is not a cycle. Otherwise, cycle</p> <p>Problem link - GFG</p>"},{"location":"6-Graph/2-Cycle-detection/6-directed-bfs-kahns/#code","title":"Code","text":"<pre><code>#User function Template for python3\nfrom typing import List\nfrom collections import deque\nclass Solution:\n\n    #Function to detect cycle in a directed graph.\n    def isCyclic(self, V : int , adj : List[List[int]]) -&gt; bool :\n        # code here\n\n        # BFS - kahns\n\n        indegree=[0]*V\n        for i in range(V):\n            for it in adj[i]:\n                indegree[it]+=1\n        q=deque()\n        for i in range(V):\n            if indegree[i]==0:\n                q.append(i)\n        topo=[]\n        while q:\n            node=q.popleft()\n            # As indegree of node is 0, we can straight away add it to topo as it cannot have any incoming edge\n            topo.append(node)\n            # As we already added the node in the topot sort, we can relax indegree for the neighbouring nodes by 1\n            for it in adj[node]:\n                indegree[it]-=1\n                if indegree[it]==0:\n                    q.append(it)\n        return len(topo)!=V\n</code></pre>"},{"location":"6-Graph/2-Cycle-detection/7-eventual-safe-states-dfs/","title":"Eventual safe states - DFS","text":"<p>Concept - If node is part of a cycle, it cant be a safe node</p> <p>Problem link - Leetcode</p>"},{"location":"6-Graph/2-Cycle-detection/7-eventual-safe-states-dfs/#intuition","title":"Intuition","text":"<ul> <li>Same as cycle detection using dfs</li> <li>Just pass a check array to mark if a node is safe or not</li> <li>Mark a node as safe if it completed all its dfs calls and did not find a cycle.</li> <li>While returning from DFS, mark pathvis as 0 as well</li> <li>if there is a cycle, return and dont mark check array as 1 or path visited as 0</li> </ul>"},{"location":"6-Graph/2-Cycle-detection/7-eventual-safe-states-dfs/#code","title":"Code","text":"<pre><code>class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -&gt; List[int]:\n        m=len(graph)\n        vis=[0]*m\n        path_vis=[0]*m\n        check=[0]*m\n        nodes=[]\n        for i in range(m):\n            if vis[i]!=1:\n                self.dfs(graph, i,vis,path_vis,check)\n        for i in range(m):\n            if check[i]==1:\n                nodes.append(i)\n        return nodes\n\n    def dfs(self,graph,i,vis,path_vis,check):\n\n        vis[i]=1\n        path_vis[i]=1\n        for it in graph[i]:\n            # print(i,it,vis,path_vis)\n            if vis[it]!=1:\n                if self.dfs(graph, it ,vis, path_vis,check) ==True:\n                    return True\n            elif path_vis[it] ==1:\n                return True\n        path_vis[i]=0\n        check[i]=1\n        return False \n</code></pre>"},{"location":"6-Graph/2-Cycle-detection/8-eventual-safe-states-topo-kahns/","title":"Eventual safe states - BFS - Topo- Kahns","text":"<p>Concept - Reverse the edges. Keep relaxing the indegree of nodes. All nodes with 0 indegree at any point can be part of topo sort</p> <p>Problem link - Leetcode</p>"},{"location":"6-Graph/2-Cycle-detection/8-eventual-safe-states-topo-kahns/#intuition","title":"Intuition","text":"<ul> <li>Reverse all the edges</li> <li>This is done to turn inoming edges in terms of outgoing edges as we are interested in outgoing edges here - terminal nodes have no outgoing edges</li> <li>Apply kahns topo sort, Keep adding all the nodes to topo ans if node is having outdegree 0</li> <li>sort topo ans and return</li> </ul>"},{"location":"6-Graph/2-Cycle-detection/8-eventual-safe-states-topo-kahns/#code","title":"Code","text":"<p>TODO - easy check strivers video </p>"},{"location":"6-Graph/3-Shortest-path/1-shortest-path-in-dag/","title":"Shortest path in DAG","text":"<p>Concept - Find topo sort, do distance comparison for adjacents</p> <p>Problem link - GFG</p>"},{"location":"6-Graph/3-Shortest-path/1-shortest-path-in-dag/#intuition","title":"Intuition","text":"<ul> <li>Find topo sort</li> <li>Take a dist array with all infinity</li> <li>Mark dist[src] as 0 </li> <li>if distance upto node + weight is less than what there is at index of dist array, replace with smaller one</li> </ul>"},{"location":"6-Graph/3-Shortest-path/1-shortest-path-in-dag/#code","title":"Code","text":"<pre><code>from typing import List\nimport math\nclass Solution:\n    def shortestPath(self, n : int, m : int, edges : List[List[int]]) -&gt; List[int]:\n        adj={}\n        for i in range(len(edges)):\n            if edges[i][0] in adj:\n                adj[edges[i][0]].append((edges[i][1],edges[i][2]))\n            else:\n                adj[edges[i][0]] = [(edges[i][1],edges[i][2])]\n\n        topo=[]\n        vis=[0]*n\n        for i in range(n):\n        # {0: [(1, 2), (4, 1)], 4: [(5, 4), (2, 2)], 1: [(2, 3)], 2: [(3, 6)], 5: [(3, 1)]}\n            if vis[i]==0:\n                self.toposort(i,adj,topo, vis)\n        dist=[math.inf]*n\n        dist[0]=0\n\n        while len(topo)!=0:\n            node =topo.pop()\n            if node in adj:\n                for it,wt in adj[node]:\n                    if dist[node]+wt&lt;dist[it]:\n                        dist[it]=dist[node]+wt\n        for i in range(n):\n            if dist[i]==math.inf:\n                dist[i]=-1\n        return dist\n\n\n    def toposort(self,node,adj,topo, vis):\n        vis[node]=1\n        if node in adj:\n            for el in adj[node]:\n                it=el[0]\n                if vis[it]==0:\n                    self.toposort(it,adj,topo,vis)\n        topo.append(node)\n</code></pre>"},{"location":"6-Graph/3-Shortest-path/2-dijkstras-min-heap/","title":"Dijkstras - using min heap","text":"<p>Concept - use min heap to store node and weight, keep replacing a distance array with shortest distance</p> <p>Problem link - GFG</p>"},{"location":"6-Graph/3-Shortest-path/2-dijkstras-min-heap/#intuition","title":"Intuition","text":"<ul> <li>Take dist array and mark all inf except source. Mark source 0</li> <li>Add source to priority queue</li> <li>While q is not empty, keep popping</li> <li>Check distance of adj nodes, replace if shorter is found</li> </ul>"},{"location":"6-Graph/3-Shortest-path/2-dijkstras-min-heap/#code-doesnot-work-as-gfg-is-shitty","title":"Code - doesnot work as GFG is shitty","text":"<pre><code>import heapq\nimport math\nclass Solution:\n\n    #Function to find the shortest distance of all the vertices\n    #from the source vertex S.\n    def dijkstra(self, V, adj, S):\n        #code here\n\n        pq=heapq.heapify([])\n\n        dist=[math.inf]*V\n        dist[S]=0\n        pq=[(0,S)]\n        adjLst={}\n        print(adj)\n        for i in range(len(adj)):\n            if i in adjLst:\n                adjLst[i].append((adj[i][1], adj[i][0]))\n            else:\n                adjLst[i]=[(adj[i][1], adj[i][0])]\n        print(adjLst)\n        print(pq)\n        print(dist)\n\n        while pq:\n            wt, node = heapq.heappop(pq)\n            if node in adjLst:\n                print(\"here\")\n                for it in adjLst[node]:\n                    adjnode=it[0]\n                    adjwt=it[1]\n                    if adjwt+dist[node] &lt; dist[adjnode]:\n                        dist[adjnode]=adjwt+dist[node]\n                        heapq.heappush(pq, (dist[adjnode], adjnode))\n        return dist\n</code></pre>"},{"location":"6-Graph/3-Shortest-path/3-dijkstras-set/","title":"Dijkstras - using set","text":"<p>Concept - using set is same as min heap - except we can delete any element in set which has more distance for a particular node, if dist[ind] != inf(which means we have some path which reached the node with a higher distance and we can remove that from the set)</p> <p>Problem link - GFG</p>"},{"location":"6-Graph/3-Shortest-path/4-print-shortest-path/","title":"Print shortest path between two nodes","text":"<p>Concept - Same as dijkstras - only maintain a parent array. Update parent array everytime we find a shorter distance. Track back parent array to get shortest path</p>"}]}